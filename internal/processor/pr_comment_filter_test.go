package processor

import (
	"context"
	"testing"

	"pr-review-automation/internal/config"
	"pr-review-automation/internal/domain"
	"pr-review-automation/internal/validator"

	"github.com/stretchr/testify/assert"
)

// MockCommenter is already defined in pr_processor_test.go

func TestValidateComments_StrictDiff(t *testing.T) {
	// Setup
	cfg := &config.Config{
		Pipeline: config.PipelineConfig{
			CommentMerge: config.CommentMergeConfig{
				Enabled: true,
			},
		},
	}
	proc := &PRProcessor{cfg: cfg}

	// Mock Diff: file1.txt has changes on lines 10-15
	diff := `diff --git a/file1.txt b/file1.txt
index abcd..1234 100644
--- a/file1.txt
+++ b/file1.txt
@@ -10,6 +10,6 @@
 line 10
 line 11
-line 12 old
+line 12 new
 line 13
 line 14
 line 15`

	v := validator.NewCommentValidator(diff)

	tests := []struct {
		name    string
		comment domain.ReviewComment
		isValid bool
	}{
		{
			name: "Valid comment on modified line",
			comment: domain.ReviewComment{
				File: "file1.txt",
				Line: 12,
			},
			isValid: true,
		},
		{
			name: "Valid comment on context line",
			comment: domain.ReviewComment{
				File: "file1.txt",
				Line: 10,
			},
			isValid: true,
		},
		{
			name: "Invalid comment outside diff (even if file in diff)",
			comment: domain.ReviewComment{
				File: "file1.txt",
				Line: 20, // Outside hunk
			},
			isValid: false, // Should be false even with merge enabled with NEW STRICT LOGIC
		},
		{
			name: "Invalid comment on non-diff file",
			comment: domain.ReviewComment{
				File: "file2.txt",
				Line: 10,
			},
			isValid: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			valid, _ := proc.validateComments([]domain.ReviewComment{tt.comment}, v)
			if tt.isValid {
				assert.NotEmpty(t, valid, "Expected valid comment but got none")
			} else {
				assert.Empty(t, valid, "Expected invalid comment but got valid")
			}
		})
	}
}

func TestFetchExistingAIComments_TableParsing(t *testing.T) {
	// Setup
	proc := &PRProcessor{
		cfg: &config.Config{},
	}

	// Mock Bitbucket Response with Merged Table Comment
	mockResponse := map[string]interface{}{
		"values": []interface{}{
			map[string]interface{}{
				"content": map[string]interface{}{
					"raw": `<!-- ai-review::file:src/main.go:commit123 -->

## ⚠️ src/main.go Code Review

| Line | Severity | Message |
|------|----------|----------|
| 15 | ⚠️ WARNING | Avoid magic numbers here. |
| 23 | INFO | Consider extracting this method. |

---
*Automatically generated by AI*`,
				},
				"inline": map[string]interface{}{
					// File-level comments often don't have inline position if they are general,
					// but our tool usually posts them as general comments if possible,
					// or we just rely on marker parsing.
					// Let's assume Bitbucket returns it as a general comment (no inline).
				},
			},
		},
	}

	mockCommenter := &MockCommenter{
		CallToolFunc: func(ctx context.Context, serverName, toolName string, args map[string]interface{}) (any, error) {
			return mockResponse, nil
		},
	}
	proc.commenter = mockCommenter

	// Execute
	comments := proc.fetchExistingAIComments(context.Background(), &domain.PullRequest{
		ID: "1", ProjectKey: "IDX", RepoSlug: "repo",
	})

	// Verify
	// We expect 2 comments extracted from the table
	assert.Len(t, comments, 2)

	// Check first comment
	found1 := false
	for _, c := range comments {
		if c.File == "src/main.go" && c.Line == 15 && c.Comment == "Avoid magic numbers here." {
			found1 = true
			break
		}
	}
	assert.True(t, found1, "Did not find comment on line 15")

	// Check second comment
	found2 := false
	for _, c := range comments {
		if c.File == "src/main.go" && c.Line == 23 && c.Comment == "Consider extracting this method." {
			found2 = true
			break
		}
	}
	assert.True(t, found2, "Did not find comment on line 23")
}
